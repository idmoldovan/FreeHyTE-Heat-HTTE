function RHS = Gen_Kp_Vector(Edges, Loops, RHS, abscissa, weight)
% GEN_KP_VECTOR iterates through the elements and calls the functions 
% that generate Kp block of the free vector (RHS) of the solving system. 
%
% GEN_KP_VECTOR is called by MAIN***. 
% Input:
% the Edges and Loops structures, the RHS vector (that is, the free vector 
% of the solving system), and the Gauss-Legendre integration parameters 
% abscissa and weights. 
% Output/Returns to MAIN*** :
% the RHS vector with the tg blocks of all elements inserted at the 
% correct positions (as determined in ASSIGNPARTS).
%
% BIBLIOGRAPHY
% 1. FreeHyTE Page - https://sites.google.com/site/ionutdmoldovan/freehyte
% 2. Moldovan ID, Cismasiu I - FreeHyTE: theoretical bases and developer’s 
% manual, https://drive.google.com/file/d/0BxuR3pKS2hNHTzB2N2Q4cXZKcGc/view
% 3. FreeHyTE Heat HTTE User's Manual - 
%    https://drive.google.com/drive/folders/0BxuR3pKS2hNHaFhiSjZHOE9TMzg
% 4. Geraldes, MRCB,  Elementos finitos híbridos-Trefftz adaptativos para
%   problemas de condução de calor. MSc Thesis, Universidade Nova de Lisboa,
%   2016 (in Portuguese).
%
% GEN_KP_VECTOR computes the internal product between the following bases, 
% expressed in a polar (r,th) referential:
% * the temperature basis U generated by harmonic polynomials, of order n 
%      U = R.^abs(n) .* exp(1i*Th.*n);
% * the particular solution, normal in local r-th (only R is needed) 
%      Up =  nr * (Q/2)*R  
% In the above expressions, n is the line of the current term in vector Kp, 
% k is the thermal conductivity coefficient (see INPUTPROC***), Q is the
% internally generated heat, and nr is the component of the boundary normal
% in the radial direction.
%
% Further details on the structure of the solving system are presented in
% reference [4] (Chapters 3 and 4).

%% Sweeping the elements
for ii=1:length(Loops.area)
   % LocLoop is a structure where the features of the current
   % element which are directly useful for the calculation of the
   % Kp block are stored.    
    LocLoop = struct('id',ii,'edges',Loops.edges(ii,:), 'center',...
        Loops.center(ii,:),'order',Loops.order(ii),...
        'insert',Loops.insert(ii),'dim',Loops.dim(ii),...
        'Q',Loops.material(ii,2));
    
    % Computing the Kpi vector of element ii. Function KPI_VECTOR_I
    % is a local function (see below). 
    Kpi = Kpi_Vector_i(Edges,LocLoop, abscissa, weight);
    
    % Inserting the vector in the global RHS vector
    RHS(LocLoop.insert:LocLoop.insert+LocLoop.dim-1) = ...
        RHS(LocLoop.insert:LocLoop.insert+LocLoop.dim-1) - Kpi;
    
end 
end 

%%
function Kpi = Kpi_Vector_i(Edges,LocLoop, abscissa, weight)
%  KPI_VECTOR_I local function computes the Kp vector of the element ii
% The sides are mapped to a [-1,1] interval to perform the integration

%% Initialization 
Kpi = zeros(LocLoop.dim,1);
Q = LocLoop.Q;

% n denotes the current line
% n + LocLoop.order + 1 is the current line;
n = -LocLoop.order:LocLoop.order;

% Iterating on the edges for contour integration
for jj = 1:length(LocLoop.edges)
    
    id = LocLoop.edges(jj);  % number of the jj-th edge of the loop
    
    % LocEdge is a local structure where the features of the current
    % edge which are directly useful for the calculation of the
    % Kp block are stored.
    LocEdge =  struct('id',id,'nini',Edges.nini(id), 'nfin',Edges.nfin(id),...
        'parametric',Edges.parametric(id,:),'lleft',Edges.lleft(id),...
        'lright',Edges.lright(id));
    
    % Constructing the matrices containing the n x abscissa
    % integration grid
    [N,A] = ndgrid(n,abscissa);
    
    %% Generating the geometric data
    % The following code transforms the abscissa coordinates, expressed in
    % the [-1,1] referential, to the polar coordinates required to compute
    % the values of the basis functions.
    
    % Computing the length of the current edge
    L = sqrt(LocEdge.parametric(3)^2 + LocEdge.parametric(4)^2);
    
    % Transforming the edge abscissa into local coordinates. The local
    % referential is centered in the barycenter of the element, its axes
    % aligned with the Cartesian axes of the global referential.
    loc_x = LocEdge.parametric(1) - LocLoop.center(1) + 0.5 *...
        (A + 1) * LocEdge.parametric(3);
    loc_y = LocEdge.parametric(2) - LocLoop.center(2) + 0.5 *...
        (A + 1) * LocEdge.parametric(4);
    
    % Transforming the local Cartesian coordinates into polar.
    R = sqrt(loc_x.^2 + loc_y.^2);  
    Th = atan2(loc_y, loc_x);
    
    % Computing the components of the outward normal in the Cartesian
    % directions.
    nx = LocEdge.parametric(4) / L;   
    ny = -1* LocEdge.parametric(3) / L;
    if LocEdge.lright==LocLoop.id  % if the element is on the right,
        nx = -nx;                  % change the sign of the normal
        ny = -ny;
    end
    
    % Computing the components of the outward normal in the R
    % direction.
    NR = nx * cos(Th) + ny * sin(Th);
    
    %% Computing the integrands at the integration points
    % Temperature basis in polar coordinates
    Ustar = conj(R.^(abs(N)) .* exp(1i*Th.*N));
    
    % Particular solution
    SPR = (Q/2)*R; %SPTh=0
    % Particular solution in the boundary normal direction
    NSP = NR.*SPR;
    
    %% Computing the integral
    % Computing the integrand
    Kpi2D = bsxfun(@times, Ustar, NSP);
    
    % computes the integral
    Kpi = Kpi + L/2 * sum(bsxfun(@times,Kpi2D,weight.'),2);
    
end 
end 
